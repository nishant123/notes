How is change detection implemented?
Angular can detect when component data changes, and then automatically re-render the view to reflect that change. But how can it do so after such a low-level event like the click of a button, that can happen anywhere on the page?


How does this low-level runtime patching work?
This low-level patching of browser APIs is done by a library shipped with Angular called Zone.js. It's important to have an idea of what a zone is.

A zone is nothing more than an execution context that survives multiple Javascript VM execution turns. It's a generic mechanism which we can use to add extra functionality to the browser. Angular uses Zones internally to trigger change detection, but another possible use would be to do application profiling, or keeping track of long stack traces that run across multiple VM turns.

yes, Zone and NgZone is used to automatically trigger change detection as a result of async operations. But since change detection is a separate mechanism it can successfully work without Zone and NgZone. In the first chapter I will show how Angular can be used without zone.js. Second part of the article explains how Angular and zone.js interact together through NgZone. In the end I’ll also show why automatic change detection sometimes doesn’t work with 3rd party libraries like Google API Client Library (gapi).

it’s expected since NgZone is not used and hence change detection is not triggered automatically. Yet it still works fine if we trigger it manually. This can be done by injecting ApplicationRef and triggering tick method to start change detection:

export class AppComponent  {
    name = 'Angular 4';

    constructor(app: ApplicationRef) {
        setTimeout(()=>{
            this.name = 'updated';
            app.tick();
        }, 1000);
    }
	
	To summarize, the point of the above demonstration is to show you that zone.js and NgZone in particular are not part of change detection implementation. It’s a very convenient mechanism to trigger change detection automatically by calling app.tick() instead of doing it manually at certain points. We will see in a minute what those points.
	
	How NgZone uses Zones
In my previous article on Zone (zone.js) I described in depth the inner working and API that Zone provides. There I explained the core concepts of forking a zone and running a task in a particular zone. I’ll be referring to those concepts here.
I also demonstrated two capabilities that Zone provides — context propagation and outstanding asynchronous tasks tracking. Angular implements NgZone class that relies heavily on the tasks tracking mechanism.
NgZone is just a wrapper around a forked child zone:

bootstrap in angular 

Method 1: Using Angular CLI (npm install). From the command line interface install bootstrap and references it in angular.json
npm install bootstrap --save


https://angular.io/guide/bootstrapping

An NgModule describes how the application parts fit together. Every application has at least one Angular module, the root module that you bootstrap to launch the application. By convention, it is usually called AppModule.

If you use the Angular CLI to generate an app, the default AppModule is as follows:

The @NgModule decorator identifies AppModule as an NgModule class. @NgModule takes a metadata object that tells Angular how to compile and launch the application.

declarations—this application's lone component.
imports—import BrowserModule to have browser specific services such as DOM rendering, sanitization, and location.
providers—the service providers.
bootstrap—the root component that Angular creates and inserts into the index.html host web page.
The default application created by the Angular CLI only has one component, AppComponent, so it is in both the declarations and the bootstrap arrays.

The declarations array
The module's declarations array tells Angular which components belong to that module. As you create more components, add them to declarations.

You must declare every component in exactly one NgModule class. If you use a component without declaring it, Angular returns an error message.

The declarations array only takes declarables. Declarables are components, directives and pipes. All of a module's declarables must be in the declarations array. Declarables must belong to exactly one module. The compiler emits an error if you try to declare the same class in more than one module.

These declared classes are visible within the module but invisible to components in a different module unless they are exported from this module and the other module imports this one.

An example of what goes into a declarations array follows:

content_copy
declarations: [
  YourComponent,
  YourPipe,
  YourDirective
],
A declarable can only belong to one module, so only declare it in one @NgModule. When you need it elsewhere, import the module that has the declarable you need in it.

Only @NgModule references go in the imports array.


https://angular.io/guide/bootstrapping

An Attribute directive changes the appearance or behavior of a DOM element. ngclass
There are three kinds of directives in Angular:

Components—directives with a template. like popup
Structural directives—change the DOM layout by adding and removing DOM elements.  if else 
Attribute directives—change the appearance or behavior of an element, component, or another directive. ngclass 

ng generate directive highlight

what is diff b/w directive and component
what is metadata with eg 

import { Directive, ElementRef } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
    constructor(el: ElementRef) {
       el.nativeElement.style.backgroundColor = 'yellow';
    }
}

<p appHighlight>Highlight me!</p>

import { Directive, ElementRef, HostListener } from '@angular/core';

Then add two eventhandlers that respond when the mouse enters or leaves, each adorned by the HostListener decorator.

@HostListener('mouseenter') onMouseEnter() {
  this.highlight('yellow');
}

@HostListener('mouseleave') onMouseLeave() {
  this.highlight(null);
}

private highlight(color: string) {
  this.el.nativeElement.style.backgroundColor = color;
}

The @HostListener decorator lets you subscribe to events of the DOM element that hosts an attribute directive, the <p> in this case.

src/app/highlight.directive.ts (constructor)
content_copy
constructor(private el: ElementRef) { }

Pass values into the directive with an @Input data binding
import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Input() highlightColor: string;
<p appHighlight [highlightColor]="'orange'">Highlighted in orange</p>
<p appHighlight [highlightColor]="color">

what is use of main.ts file
https://angular.io/guide/architecture


main.ts is the entry point of your application , compiles the application with just-in-time and bootstraps the application .Angular can be bootstrapped in multiple environments we need to import a module specific to the environment. in which angular looks for which module would run first.

// The browser platform with a compiler

import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

// The app module

import { AppModule } from './app/app.module';

// Compile and launch the module

platformBrowserDynamic().bootstrapModule(AppModule);


APP.MODULE.TS

This is root module that tells Angular how to assemble the application . Every Angular app has a root module class

@NgModule — takes a metadata object that tells Angular how to compile and launch the application.

Imports — the BrowserModule that this and every application needs to run in a browser.

Declarations — the application's component.

Bootstrap — this is the root component tells which component to run first.

enableProdMode - Disable Angular's development mode, which turns off assertions and other checks within the framework.

platformBrowserDynamic - To boostrap your app for browsers

AppModule - The root module which inform Angular about various files and codes.

environment - Environment Variables in Angular read this

app.module.ts:

Component
It is also a type of directive with template,styles and logic part which is most famous type of directive among all in Angular2. In this type of directive you can use other directives whether it is custom or builtin in the @Component annotation like following:

The Complete Guide to Angular Performance Tuning

https://christianlydemann.com/the-complete-guide-to-angular-performance-tuning/

Improving change detection
Change detection can be the most performance heavy in Angular apps and therefore it is necessary to have some awareness of how to render the templates most effectively, so you are only rerendering a component if it has new changes to show.

OnPush change detection
The default change detection behavior for components is to re-render every time an asynchronous event has happened in the app such as click, XMLHttpRequest, setTimout. This can become a problem because this will cause many unnecessary renderings of the templates, that may not have been changed

OnPush change detection fixes this by only re-rendering a template if either:

One of its input properties has gotten a new reference
An event from the component or one of its children eg. click on a button in the component
Explicit run of change detection
To apply this strategy you just need to set the change-detection strategy in the component’s decorator:

@Component({
  selector: 'app-todo-list',
  templateUrl: './todo-list.component.html',
  styleUrls: ['./todo-list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class TodoListComponent implements OnInit {


Design for immutability  (unchanging over time)

To leverage this method you need to make sure, that all state changes are happening immutably because we need a new reference provided to a component’s input to trigger change detection with onPush. If you are using Redux for state management, then you would naturally get a new instance every time the state changes, which will trigger change detection for onPush components when provided to a component’s inputs. With this approach you want to have container components, that is responsible for getting the data from the store and presentation component, which will only interact with other components using input and output.

presentation component <-> container component <-> redux store 

The easiest way to provide the store data to the template is using the async pipe. This will look like having the data outside of an observable and will make sure to clean up the stream when the component gets destroyed automatically.

<div class="todo-list-wrapper" *ngIf="(todoList$ | async) as todoList">

Make onPush the default change detection strategy
Using schematics you can make onPush the default changeDetection strategy when generating new components with Angular CLI. You simply add this to the schematics property in Angular.json:

 "changeDetection": "OnPush"
 
 Using pipes instead of methods in templates
Methods in a template will get triggered every time a component gets rerendered. Even with onPush change detection, that will mean that it gets triggered every time there is interaction with the component or any children of the component (click, type). If the methods are doing heavy computations, this will make the app slow as it scales as it keeps recomputing every time there is interaction with the component.

What you can do instead is using a pure pipe to make sure, that you are only recomputing when the input to the pipe changes. async pipe, as we looked at before, is an example of a pure pipe. 

A pure function
There’s so much information on the web about functional programming that probably every developer knows what a pure function is. For myself I define a pure function as a function that doesn’t have an internal state. It means that all operations it performs are not affected by that state and given the same input parameters and produces the same deterministic output.

const addPure = (v1, v2) => {
  return v1 + v2;
};

const addImpure = (() => {
  let state = 0;
  return (v) => {
    return state += v;
  }
})();

If I call both functions with the same input, say number 1, the first one will produce the same output 2 on every call:

addPure(1, 1);  // 2
addPure(1, 1);  // 2
addPure(1, 1);  // 2
while the second one produces different output:
addImpure(1);  // 1
addImpure(1);  // 2
addImpure(1);  // 3

So the key takeaway here is that even if the input doesn’t change the impure function can produce different output. It means that we cannot use the input value to determine if the output will change.

Pure:
input parameters value determine the output so if input parameters don’t change the output doesn’t change
can be shared across many usages without affecting the output result
Impure:
cannot use the input value to determine if the output will change
cannot be shared because the internal state can be affected from outside

This has the consequence of triggering the method every time a button is clicked inside of the component that is even using onPush change detection:

With pipe
We fix this by converting the method to a pipe, as a pipe as default is pure it will rerun the logic if the input changes (reference change).
Now, this pipe is only being triggered when the input (todolist) has changed.

Cache values from pure pipes and functions
Even when using pure pipes, we can optimize this further by remembering/caching previous values, so we don’t need to recompute if we already run the pipe with the same input in the past. Pure pipes don’t remember the previous values, but will just make sure that if the input hasn’t changed the reference, it will not recompute. To do the caching of previous value we need to combine it with something else.
An easy way to do this is to use Lodash memorize method. In this case, this is not very practical as the input is an array of objects. If the pipe was taking a simple data type, such as number as input, it could be beneficial to use this as a key to cache results and thus avoid recomputation.


Using trackBy in ngFor
When using ngFor and updating the list, Angular will by default remove the whole list from the DOM and create it again, because it has no way, by default, to know which item has been added or removed from the list. The trackBy function is solving this by allowing you to provide Angular with a function used for evaluating, which item has been updated or removed from the ngFor list, and then only rerender that.

 public trackByFn(index, item) {
    return item.id;
  }
  
  This will track changes in the list based on the id property of the items (todo items).

The trackBy function is used in the template like this:

<ul class="list-group mb-3">
    <app-todo-item-list-row *ngFor="let todo of todos; trackBy: trackByFn" [todoItem]="todo" (todoDelete)="deleteTodo($event)" (todoEdit)="editTodo($event)"></app-todo-item-list-row>
  </ul>
  
  Improving page load
The page load time is an important aspect of user experience today. Every millisecond a user is waiting, potentially means a loss in revenue, because of a higher bounce rate and worse user experience, so this is a place you should optimize. Page load time also has an impact on SEO, as faster websites are rewarded by search engines.

For improving page load we want to use caching using Angular PWA, lazy loading and bundling.

Cache static content using Angular PWA
Caching the static content will make your Angular app load faster as it will already be in the browser. This is easily done using Angular PWA which will use service workers to cache the static content, that is the js, css bundles, images and static served files, and present them without making a call to the server.

I have already created a guide to how to setup caching with Angular PWA you can read here.

Cache HTTP calls using Angular PWA
With Angular PWA you can easily set up caching rules for HTTP calls to give a faster user experience without cluttering your app with a lot of caching code. Either you can optimize for freshness or performance, that is, you can either choose to only read the cache if the HTTP call times out or first check the cache and then only call the API then the cache expires.

I have a guide with a video showing you how to do this here.


Lazy load routes
Lazy loading routes will make sure that a feature will be bundled in its own bundle and that this bundle can be loaded when it is needed.

To set up lazy loading we simply create a child route file like this in a feature:

Optimizing bundling and preloading
To optimize page load even further you can choose to preload the feature modules, so navigation is instant when you want to render a lazily loaded feature module.
This can be done by setting the: preloadingStrategy to PreloadModules as:

    RouterModule.forRoot(routes, {
      preloadingStrategy: PreloadAllModules
    })
	
	Server-side rendering with Angular Universal
For Angular apps that are containing indexed pages, it is recommended to server-side render the app. This will make sure the pages are being fully rendered by the server before shown to the browser which will give a faster page load. This will require that the app is not dependent on any native DOM elements, and you should instead inject 

Improving UX
Performance tuning is all about optimizations at the bottleneck, that is the part of the system that is affecting your user experience the most. Sometimes the solution could just be to handle actions more optimistically and thus less waiting for the user.

How should I prioritize performance tuning?
Start with low hanging fruits: onPush, Lazy loading and then PWA and then gain awareness of where your performance bottlenecks are in the system. Every improvement that is not at the bottleneck is an illusion as it will not improve the user experience with the app. Tuning methods like detaching the change detection should only be used if you have a specific problem with a component’s change detection impacting performance.

OnPush
Lazy loading modules
Improve page load with Angular PWA
trackBy for ngFor
Pure pipes instead of methods (including async)
Cache values from pipes and pure functions
Cache HTTP requests better
Detach/manual change detection
Angular Universal

Why is Angular Universal the last one? Because introducing server-side rendering can cause big changes to the development setup (need to maintain another server, cannot reference DOM and need to maintain a server and a client bundle) and should be used either for performance reasons that can not be fixed with the previous steps or SEO purposes.

https://github.com/lydemann/angular-performance-tuning-guide

angular trainer

github.com/lydemann

christianlydemann.com/
git

https://christianlydemann.com/angular-architect-course-video/


AOT Compilation
When running a production build, Angular using JIT (just in time) compilation, which essentially means, Angular compiles your views in the browser at runtime. This has two downsides. First, the compilation process must run before your application can be used, and this can increase the time it takes for your site to load. Secondly, we have to ship the Angular compiler with your application, and it is not a small module!

By taking advantage of AOT (ahead of time) compilation, we move this step to build time so we do it once when building our application, and only ship the compiled templates. We can now remove the Angular compiler from our bundle (reducing our bundle size by ~1mb) and allows us to skip the compilation step making our pages load much quicker!

Minification
Code minification is the process tools like UglifyJS perform to optimize the code we have written. It performs many optimizations, for example, removing whitespace, renaming properties, dead code elimination and much much more.

When developing having well named variables make development much easier, but when shipping our applications we don’t need these names to be so helpful, so while averageUserAge might be useful when developing this could be renamed to a1 reducing the amount of code needed to be shipped.


12. Unsubscribe
As previously mentioned, Angular uses observables quite a lot, and if you make any HTTP requests or are listening to router events, you will too.

Observables are great, but you need to ensure once you are finished with them that you unsubscribe, otherwise memory leaks can occur and this can cause performance issues.

Unsubscribing is easy, you store the subscription, and then use the ngOnDestroy lifecycle hook to unsubscribe, eg:

export class AppComponent implements OnDestroy {
    private _subscription: Subscription;

    constructor(router: Router) {
        this._subscription = router.events.subscribe(event => {
            // do stuff here

        });
    }

    ngOnDestroy(): void {
        this._subscription.unsubscribe();
    }
}


14. Profiling
There are many things that I can list to improve performance and even if your application followed everything listed here you may still have performance issues. That is simply because each application is different, it will use different third party libraries and be architected differently. And this is where profiling comes in!

The developer tools for all modern browser come equipped with performance profiling tools to help identify code that is running slowly, which is great to help figure out how you can improve it further.

There are a few other tools you can use to help improve performance, first the Webpack Bundle Analyzer. This tool allows you to visually explore your bundle. It can let you see what modules or libraries are the largest, but more importantly it can help identify items that should not have been included in the bundle. For example if you are using an older version of RxJS, accidentally importing directly from rxjs would have included the whole library in your bundle. Tools like this can help spot this kind of mistake and allow you to easily rectify it.


Lighthouse testing is another great way to see how you application performs on a range of devices. It is a tool now built in to the Chrome Dev Tools. It will profile many aspects of your application, such a load performance, accessibility, PWA support, SEO optimization and Best Practices. It can also give you a good indication about how well your site will perform in regards to Google rankings as many of these criteria it tests for will affect the site ranking.







