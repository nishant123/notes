best practices for angular

1. Use of Angular CLI
Angular comes equipped with a command line interface called Angular CLI, which helps you scaffold your code in minutes.
Angular CLI can be installed easily via terminal by typing in the following command:
npm install -g @angular/cli

To generate and start a new project locally, us
ng new PROJECT-NAME
cd PROJECT-NAME
ng serve -o

2. Develop Angular apps in modular fashion using core, shared and feature modules
When you start developing in Angular, you may be tempted to disregard creation of modules for the sake of using components solely. That approach might be fine for smaller apps, but as your app starts to grow, development will become cumbersome. That‚Äôs when separation of concerns steps in, which is fueled by a modular Angular app.
Splitting your app into core, shared and multiple feature modules will make your life much easier. Each module can have its own components, services, directives and pipes.


2. Develop Angular apps in modular fashion using core, shared and feature modules
When you start developing in Angular, you may be tempted to disregard creation of modules for the sake of using components solely. That approach might be fine for smaller apps, but as your app starts to grow, development will become cumbersome. That‚Äôs when separation of concerns steps in, which is fueled by a modular Angular app.
Splitting your app into core, shared and multiple feature modules will make your life much easier. Each module can have its own components, services, directives and pipes.
Core module should be created of components (i.e. header, main navigation, footer) that will be used across the entire app.
Shared module can have components, directives and pipes that will be shared across multiple modules and components, but not the entire app necessarily.
Last but not least are feature modules. Per Angular‚Äôs official documentation, feature module is:
an organizational best practice, as opposed to a concept of the core Angular API. A feature module delivers a cohesive set of functionality focused on a specific application need such as a user workflow, routing, or forms. While you can do everything within the root module, feature modules help you partition the app into focused areas. A feature module collaborates with the root module and with other modules through the services it provides and the components, directives, and pipes that it shares.








observable and promise check

In order to show how subscribing works, we need to create a new observable. There is a constructor that you use to create new instances, but for illustration, we can use some methods from the RxJS library that create simple observables of frequently used types:

of(...items)‚ÄîReturns an Observable instance that synchronously delivers the values provided as arguments.
from(iterable)‚ÄîConverts its argument to an Observable instance. This method is commonly used to convert an array to an observable.


Observables provide support for passing messages between publishers and subscribers in your application. Observables offer significant benefits over other techniques for event handling, asynchronous programming, and handling multiple values.

Observables are declarative‚Äîthat is, you define a function for publishing values, but it is not executed until a consumer subscribes to it. The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.

An observable can deliver multiple values of any type‚Äîliterals, messages, or events, depending on the context. The API for receiving values is the same whether the values are delivered synchronously or asynchronously. Because setup and teardown logic are both handled by the observable, your application code only needs to worry about subscribing to consume values, and when done, unsubscribing. Whether the stream was keystrokes, an HTTP response, or an interval timer, the interface for listening to values and stopping listening is the same.

Because of these advantages, observables are used extensively within Angular, and are recommended for app development as well.

To execute the observable you have created and begin receiving notifications, you call its subscribe() method, passing an observer. This is a JavaScript object that defines the handlers for the notifications you receive. The subscribe() call returns a Subscription object that has an unsubscribe() method, which you call to stop receiving notifications.


hat actually the difference is?
Promise emits a single value while Observable emits multiple values. So, while handling a HTTP request, Promise can manage a single response for the same request, but what if there are multiple responses to the same request, then we have to use Observable. Yes, Observable can handle multiple responses for the same request.
Let‚Äôs implement this with an example.

Promise
const promise = new Promise((data) =>
{ data(1);
  data(2);
  data(3); })
.then(element => console.log(‚ÄòPromise ‚Äò + element));

Output

Promise 1

Observable

const observable = new Observable((data) => {
data.next(1);
data.next(2);
data.next(3);
}).subscribe(element => console.log('Observable ' + element));

Output

Observable 1
Observable 2
Observable 3

So, in the above code snippet, I have created promise and observable of Promise and Observable type respectively. But, promise returns the very first value and ignore the remaining values whereas Observable return all the value and print 1, 2, 3 in the console.

Promise is not lazy while Observable is lazy. Observable is lazy in nature and do not return any value until we subscribe.

home.component.ts (Observable)

1
getMenu() {
2
this.homeService.getFoodItem();
3
}
4
}
In above example we are not subscribing the observable, so we do not receive the data and even there would be a no network call for this service.

home.component.ts (Observable)

1
getMenu() {
2
this.homeService.getFoodItem().subscribe((data  => {
3
this.foodItem = data;
4
}),
5
error => console.log(error));
6
}
7
}
Here, we have subscribed our Observable, so it will simply return the data. But Promise returns the value regardless of then() method.

home.component.ts (Promise)

1
getMenu() {
2
this.homeService.getFoodItem()
3
.then((data) => {
4
this.foodItem = data;
5
});
6
}
Observable is cancellable in nature by invoking unsubscribe() method, but Promise is not cancellable in nature.

Hope this is helpful and give you a basic understanding of how Promise differs from Observable. Please feel free to provide your suggestions üôÇ

The RxJS library
Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change (Wikipedia). RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables that makes it easier to compose asynchronous or callback-based code. See (RxJS Docs).

Observable creation functions
RxJS offers a number of functions that can be used to create new observables. These functions can simplify the process of creating observables from things such as events, timers, promises, and so on. 

Create an observable from a promise
content_copy
import { from } from 'rxjs';

// Create an Observable out of a promise
const data = from(fetch('/api/endpoint'));
// Subscribe to begin listening for async result
data.subscribe({
  next(response) { console.log(response); },
  error(err) { console.error('Error: ' + err); },
  complete() { console.log('Completed'); }
});


import { interval } from 'rxjs';

// Create an Observable that will publish a value on an interval
const secondsCounter = interval(1000);
// Subscribe to begin publishing values
secondsCounter.subscribe(n =>
  console.log(`It's been ${n} seconds since subscribing!`));
  
  Create an observable from an event
  
  import { fromEvent } from 'rxjs';

const el = document.getElementById('my-element');

// Create an Observable that will publish mouse movements
const mouseMoves = fromEvent(el, 'mousemove');

// Subscribe to start listening for mouse-move events
const subscription = mouseMoves.subscribe((evt: MouseEvent) => {
  // Log coords of mouse movements
  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);

  // When the mouse is over the upper-left of the screen,
  // unsubscribe to stop listening for mouse movements
  if (evt.clientX < 40 && evt.clientY < 40) {
    subscription.unsubscribe();
  }
});


Create an observable that creates an AJAX request

import { ajax } from 'rxjs/ajax';

// Create an Observable that will create an AJAX request
const apiData = ajax('/api/data');
// Subscribe to create the request
apiData.subscribe(res => console.log(res.status, res.response));

Operators are functions that build on the observables foundation to enable sophisticated manipulation of collections. For example, RxJS defines operators such as map(), filter(), concat(), and flatMap().

Operators take configuration options, and they return a function that takes a source observable. When executing this returned function, the operator observes the source observable‚Äôs emitted values, transforms them, and returns a new observable of those transformed values. Here is a simple example:

Map operator
content_copy
import { map } from 'rxjs/operators';

const nums = of(1, 2, 3);

const squareValues = map((val: number) => val * val);
const squaredNums = squareValues(nums);

squaredNums.subscribe(x => console.log(x));



You can use pipes to link operators together. Pipes let you combine multiple functions into a single function. The pipe() function takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.

A set of operators applied to an observable is a recipe‚Äîthat is, a set of instructions for producing the values you‚Äôre interested in. By itself, the recipe doesn‚Äôt do anything. You need to call subscribe() to produce a result through the recipe







import { filter, map } from 'rxjs/operators';

const nums = of(1, 2, 3, 4, 5);

// Create a function that accepts an Observable.
const squareOddVals = pipe(
  filter((n: number) => n % 2 !== 0),
  map(n => n * n)
);

// Create an Observable that will run the filter and map functions
const squareOdd = squareOddVals(nums);

// Subscribe to run the combined functions
squareOdd.subscribe(x => console.log(x));

The pipe() function is also a method on the RxJS Observable, so you use this shorter form to define the same operation:

import { filter, map } from 'rxjs/operators';

const squareOdd = of(1, 2, 3, 4, 5)
  .pipe(
    filter(n => n % 2 !== 0),
    map(n => n * n)
  );

// Subscribe to get values
squareOdd.subscribe(x => console.log(x));


Common operators
RxJS provides many operators, but only a handful are used frequently. For a list of operators and usage samples, visit the RxJS API Documentation.


Error handling
In addition to the error() handler that you provide on subscription, RxJS provides the catchError operator that lets you handle known errors in the observable recipe.

For instance, suppose you have an observable that makes an API request and maps to the response from the server. If the server returns an error or the value doesn‚Äôt exist, an error is produced. If you catch this error and supply a default value, your stream continues to process values rather than erroring out.

Here's an example of using the catchError operator to do this:




import { ajax } from 'rxjs/ajax';
import { map, catchError } from 'rxjs/operators';
// Return "response" from the API. If an error happens,
// return an empty array.
const apiData = ajax('/api/data').pipe(
  map(res => {
    if (!res.response) {
      throw new Error('Value expected!');
    }
    return res.response;
  }),
  catchError(err => of([]))
);

apiData.subscribe({
  next(x) { console.log('data: ', x); },
  error(err) { console.log('errors already caught... will not run'); }
});



Naming conventions for observables
Because Angular applications are mostly written in TypeScript, you will typically know when a variable is an observable. Although the Angular framework does not enforce a naming convention for observables, you will often see observables named with a trailing ‚Äú$‚Äù sign.


This can be useful when scanning through code and looking for observable values. Also, if you want a property to store the most recent value from an observable, it can be convenient to simply use the same name with or without the ‚Äú$‚Äù.


import { Component } from '@angular/core';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-stopwatch',
  templateUrl: './stopwatch.component.html'
})
export class StopwatchComponent {

  stopwatchValue: number;
  stopwatchValue$: Observable<number>;

  start() {
    this.stopwatchValue$.subscribe(num =>
      this.stopwatchValue = num
    );
  }
}



directive


At the core, a directive is a function that executes whenever the Angular compiler finds it in the DOM. Angular directives are used to extend the power of the HTML by giving it new syntax. Each directive has a name ‚Äî either one from the Angular predefined like ng-repeat, or a custom one which can be called anything. And each directive determines where it can be used: in an element, attribute, class or comment.



Components
As we saw earlier, components are just directives with templates. Under the hood, they use the directive API and give us a cleaner way to define them.

The other two directive types don‚Äôt have templates. Instead, they‚Äôre specifically tailored to DOM manipulation.

Attribute directives
Attribute directives manipulate the DOM by changing its behavior and appearance.

We use attribute directives to apply conditional style to elements, show or hide elements or dynamically change the behavior of a component according to a changing property.
like  ngclass

Structural directives
These are specifically tailored to create and destroy DOM elements.

Some attribute directives ‚Äî like hidden, which shows or hides an element ‚Äî basically maintain the DOM as it is. But the structural Angular directives are much less DOM friendly, as they add or completely remove elements from the DOM. So, when using these, we have to be extra careful, since we‚Äôre actually changing the HTML structure.

import {Directive, ElementRef} from '@angular/core';

@Directive({
    selector:'[my-error]'
})

export class MyErrorDirective{
    constructor(elr:ElementRef){
        elr.nativeElement.style.background='red';
    }
}

After importing the Directive from @angular/core we can then use it. First, we need a selector, which gives a name to the directive. In this case, we call it my-error.

Best practice dictates that we always use a prefix when naming our Angular directives. This way, we‚Äôre sure to avoid conflicts with any standard HTML attributes. We also shouldn‚Äôt use the ng prefix. That one‚Äôs used by Angular, and we don‚Äôt want to confuse our custom created Angular directives with Angular predefined ones. In this example, our prefix is my-.

We then created a class, MyErrorDirective. To access any element of our DOM, we need to use ElementRef. Since it also belongs to the @angular/core package, it‚Äôs a simple matter of importing it together with the Directive and using it.

We then added the code to actually highlight the constructor of our class.

To be able to use this newly created directive, we need to add it to the declarations on the app.module.ts file:

import { MyErrorDirective } from './app.myerrordirective';

Creating a structural directive
In the previous section, we saw how to create an attribute directive using Angular. The approach for creating a structural behavior is exactly the same. We create a new file with the code for our directive, then we add it to the declarations, and finally, we use it in our component.

For our structural directive, we‚Äôll implement a copy of the ngIf directive. This way, we‚Äôll not only be implementing a directive, but also taking a look at how Angular directives handle things behind the scenes.

Let‚Äôs start with our app.mycustomifdirective.ts file:


import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
    selector: '[myCustomIf]'
})

export class MyCustomIfDirective {

    constructor(
        private templateRef: TemplateRef<any>,
        private viewContainer: ViewContainerRef) { }

    @Input() set myCustomIf(condition: boolean) {
        if (condition) {
            this.viewContainer.createEmbeddedView(this.templateRef);
        } else {
            this.viewContainer.clear();
        }
    }
}


As we can see, we‚Äôre using a couple of different imports for this one, mainly: Input, TemplateRef and ViewContainerRef. The Input decorator is used to pass data to the component. The TemplateRef one is used to instantiate embedded views. An embedded view represents a part of a layout to be rendered, and it‚Äôs linked to a template. Finally, the ViewContainerRef is a container where one or more Views can be attached. Together, these components work as follow




for component 

import { Component, OnInit, Input } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'app-hero-detail',
  templateUrl: './hero-detail.component.html',
  styleUrls: ['./hero-detail.component.css']
})



Architecture overview
Angular is a platform and framework for building client applications in HTML and TypeScript. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your apps.

The basic building blocks of an Angular application are NgModules, which provide a compilation context for components. NgModules collect related code into functional sets; an Angular app is defined by a set of NgModules. An app always has at least a root module that enables bootstrapping, and typically has many more feature modules.

Components define views, which are sets of screen elements that Angular can choose among and modify according to your program logic and data.

Components use services, which provide specific functionality not directly related to views. Service providers can be injected into components as dependencies, making your code modular, reusable, and efficient.

Both components and services are simply classes, with decorators that mark their type and provide metadata that tells Angular how to use them.

The metadata for a component class associates it with a template that defines a view. A template combines ordinary HTML with Angular directives and binding markup that allow Angular to modify the HTML before rendering it for display.

The metadata for a service class provides the information Angular needs to make it available to components through dependency injection (DI).

An app's components typically define many views, arranged hierarchically. Angular provides the Router service to help you define navigation paths among views. The router provides sophisticated in-browser navigational capabilities.


Modules
Angular NgModules differ from and complement JavaScript (ES2015) modules. An NgModule declares a compilation context for a set of components that is dedicated to an application domain, a workflow, or a closely related set of capabilities. An NgModule can associate its components with related code, such as services, to form functional units.

Every Angular app has a root module, conventionally named AppModule, which provides the bootstrap mechanism that launches the application. An app typically contains many functional modules.

Like JavaScript modules, NgModules can import functionality from other NgModules, and allow their own functionality to be exported and used by other NgModules. For example, to use the router service in your app, you import the Router NgModule.

Organizing your code into distinct functional modules helps in managing development of complex applications, and in designing for reusability. In addition, this technique lets you take advantage of lazy-loading‚Äîthat is, loading modules on demand‚Äîto minimize the amount of code that needs to be loaded at startup.

Feature Modules
Feature modules are NgModules for the purpose of organizing code.

For the final sample app with a feature module that this page describes, see the live example / download example.

As your app grows, you can organize code relevant for a specific feature. This helps apply clear boundaries for features. With feature modules, you can keep code related to a specific functionality or feature separate from other code. Delineating areas of your app helps with collaboration between developers and teams, separating directives, and managing the size of the root module.

Feature modules vs. root modules
A feature module is an organizational best practice, as opposed to a concept of the core Angular API. A feature module delivers a cohesive set of functionality focused on a specific application need such as a user workflow, routing, or forms. While you can do everything within the root module, feature modules help you partition the app into focused areas. A feature module collaborates with the root module and with other modules through the services it provides and the components, directives, and pipes that it shares.

How to make a feature module
Assuming you already have an app that you created with the Angular CLI, create a feature module using the CLI by entering the following command in the root project directory. Replace CustomerDashboard with the name of your module. You can omit the "Module" suffix from the name because the CLI appends it:


ng generate module CustomerDashboard

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: []
})
export class CustomerDashboardModule { }

Importing a feature module

To incorporate the feature module into your app, you have to let the root module, app.module.ts, know about it. Notice the CustomerDashboardModule export at the bottom of customer-dashboard.module.ts. This exposes it so that other modules can get to it. To import it into the AppModule, add it to the imports in app.module.ts and to the imports array:



Types of Feature Modules
There are five general categories of feature modules which tend to fall into the following groups:

Domain feature modules.
Routed feature modules.
Routing modules.
Service feature modules.
Widget feature modules.

Feature Module	Guidelines
Domain	Domain feature modules deliver a user experience dedicated to a particular application domain like editing a customer or placing an order.
They typically have a top component that acts as the feature root and private, supporting sub-components descend from it.

Domain feature modules consist mostly of declarations. Only the top component is exported.

Domain feature modules rarely have providers. When they do, the lifetime of the provided services should be the same as the lifetime of the module.

Domain feature modules are typically imported exactly once by a larger feature module.

They might be imported by the root AppModule of a small application that lacks routing.

Routed	Routed feature modules are domain feature modules whose top components are the targets of router navigation routes.
All lazy-loaded modules are routed feature modules by definition.

Routed feature modules don‚Äôt export anything because their components never appear in the template of an external component.

A lazy-loaded routed feature module should not be imported by any module. Doing so would trigger an eager load, defeating the purpose of lazy loading.That means you won‚Äôt see them mentioned among the AppModule imports. An eager loaded routed feature module must be imported by another module so that the compiler learns about its components.

Routed feature modules rarely have providers for reasons explained in Lazy Loading Feature Modules. When they do, the lifetime of the provided services should be the same as the lifetime of the module. Don't provide application-wide singleton services in a routed feature module or in a module that the routed module imports.

Routing	
A routing module provides routing configuration for another module and separates routing concerns from its companion module.

A routing module typically does the following:

Defines routes.
Adds router configuration to the module's imports.
Adds guard and resolver service providers to the module's providers.
The name of the routing module should parallel the name of its companion module, using the suffix "Routing". For example, FooModule in foo.module.ts has a routing module named FooRoutingModule in foo-routing.module.ts. If the companion module is the root AppModule, the AppRoutingModule adds router configuration to its imports with RouterModule.forRoot(routes). All other routing modules are children that import RouterModule.forChild(routes).
A routing module re-exports the RouterModule as a convenience so that components of the companion module have access to router directives such as RouterLink and RouterOutlet.
A routing module does not have its own declarations. Components, directives, and pipes are the responsibility of the feature module, not the routing module.
A routing module should only be imported by its companion module.

Service	
Service modules provide utility services such as data access and messaging. Ideally, they consist entirely of providers and have no declarations. Angular's HttpClientModule is a good example of a service module.

The root AppModule is the only module that should import service modules.

Widget	
A widget module makes components, directives, and pipes available to external modules. Many third-party UI component libraries are widget modules.

A widget module should consist entirely of declarations, most of them exported.

A widget module should rarely have providers.

Import widget modules in any module whose component templates need the widgets.













How is change detection implemented?
Angular can detect when component data changes, and then automatically re-render the view to reflect that change. But how can it do so after such a low-level event like the click of a button, that can happen anywhere on the page?


How does this low-level runtime patching work?
This low-level patching of browser APIs is done by a library shipped with Angular called Zone.js. It's important to have an idea of what a zone is.

A zone is nothing more than an execution context that survives multiple Javascript VM execution turns. It's a generic mechanism which we can use to add extra functionality to the browser. Angular uses Zones internally to trigger change detection, but another possible use would be to do application profiling, or keeping track of long stack traces that run across multiple VM turns.

yes, Zone and NgZone is used to automatically trigger change detection as a result of async operations. But since change detection is a separate mechanism it can successfully work without Zone and NgZone. In the first chapter I will show how Angular can be used without zone.js. Second part of the article explains how Angular and zone.js interact together through NgZone. In the end I‚Äôll also show why automatic change detection sometimes doesn‚Äôt work with 3rd party libraries like Google API Client Library (gapi).

it‚Äôs expected since NgZone is not used and hence change detection is not triggered automatically. Yet it still works fine if we trigger it manually. This can be done by injecting ApplicationRef and triggering tick method to start change detection:

export class AppComponent  {
    name = 'Angular 4';

    constructor(app: ApplicationRef) {
        setTimeout(()=>{
            this.name = 'updated';
            app.tick();
        }, 1000);
    }
	
	To summarize, the point of the above demonstration is to show you that zone.js and NgZone in particular are not part of change detection implementation. It‚Äôs a very convenient mechanism to trigger change detection automatically by calling app.tick() instead of doing it manually at certain points. We will see in a minute what those points.
	
	How NgZone uses Zones
In my previous article on Zone (zone.js) I described in depth the inner working and API that Zone provides. There I explained the core concepts of forking a zone and running a task in a particular zone. I‚Äôll be referring to those concepts here.
I also demonstrated two capabilities that Zone provides ‚Äî context propagation and outstanding asynchronous tasks tracking. Angular implements NgZone class that relies heavily on the tasks tracking mechanism.
NgZone is just a wrapper around a forked child zone:

bootstrap in angular 

Method 1: Using Angular CLI (npm install). From the command line interface install bootstrap and references it in angular.json
npm install bootstrap --save


https://angular.io/guide/bootstrapping

An NgModule describes how the application parts fit together. Every application has at least one Angular module, the root module that you bootstrap to launch the application. By convention, it is usually called AppModule.

If you use the Angular CLI to generate an app, the default AppModule is as follows:

The @NgModule decorator identifies AppModule as an NgModule class. @NgModule takes a metadata object that tells Angular how to compile and launch the application.

declarations‚Äîthis application's lone component.
imports‚Äîimport BrowserModule to have browser specific services such as DOM rendering, sanitization, and location.
providers‚Äîthe service providers.
bootstrap‚Äîthe root component that Angular creates and inserts into the index.html host web page.
The default application created by the Angular CLI only has one component, AppComponent, so it is in both the declarations and the bootstrap arrays.

The declarations array
The module's declarations array tells Angular which components belong to that module. As you create more components, add them to declarations.

You must declare every component in exactly one NgModule class. If you use a component without declaring it, Angular returns an error message.

The declarations array only takes declarables. Declarables are components, directives and pipes. All of a module's declarables must be in the declarations array. Declarables must belong to exactly one module. The compiler emits an error if you try to declare the same class in more than one module.

These declared classes are visible within the module but invisible to components in a different module unless they are exported from this module and the other module imports this one.

An example of what goes into a declarations array follows:

content_copy
declarations: [
  YourComponent,
  YourPipe,
  YourDirective
],
A declarable can only belong to one module, so only declare it in one @NgModule. When you need it elsewhere, import the module that has the declarable you need in it.

Only @NgModule references go in the imports array.


https://angular.io/guide/bootstrapping

An Attribute directive changes the appearance or behavior of a DOM element. ngclass
There are three kinds of directives in Angular:

Components‚Äîdirectives with a template. like popup
Structural directives‚Äîchange the DOM layout by adding and removing DOM elements.  if else 
Attribute directives‚Äîchange the appearance or behavior of an element, component, or another directive. ngclass 

ng generate directive highlight

what is diff b/w directive and component
what is metadata with eg 

import { Directive, ElementRef } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
    constructor(el: ElementRef) {
       el.nativeElement.style.backgroundColor = 'yellow';
    }
}

<p appHighlight>Highlight me!</p>

import { Directive, ElementRef, HostListener } from '@angular/core';

Then add two eventhandlers that respond when the mouse enters or leaves, each adorned by the HostListener decorator.

@HostListener('mouseenter') onMouseEnter() {
  this.highlight('yellow');
}

@HostListener('mouseleave') onMouseLeave() {
  this.highlight(null);
}

private highlight(color: string) {
  this.el.nativeElement.style.backgroundColor = color;
}

The @HostListener decorator lets you subscribe to events of the DOM element that hosts an attribute directive, the <p> in this case.

src/app/highlight.directive.ts (constructor)
content_copy
constructor(private el: ElementRef) { }

Pass values into the directive with an @Input data binding
import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Input() highlightColor: string;
<p appHighlight [highlightColor]="'orange'">Highlighted in orange</p>
<p appHighlight [highlightColor]="color">

what is use of main.ts file
https://angular.io/guide/architecture


main.ts is the entry point of your application , compiles the application with just-in-time and bootstraps the application .Angular can be bootstrapped in multiple environments we need to import a module specific to the environment. in which angular looks for which module would run first.

// The browser platform with a compiler

import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

// The app module

import { AppModule } from './app/app.module';

// Compile and launch the module

platformBrowserDynamic().bootstrapModule(AppModule);


APP.MODULE.TS

This is root module that tells Angular how to assemble the application . Every Angular app has a root module class

@NgModule ‚Äî takes a metadata object that tells Angular how to compile and launch the application.

Imports ‚Äî the BrowserModule that this and every application needs to run in a browser.

Declarations ‚Äî the application's component.

Bootstrap ‚Äî this is the root component tells which component to run first.

enableProdMode - Disable Angular's development mode, which turns off assertions and other checks within the framework.

platformBrowserDynamic - To boostrap your app for browsers

AppModule - The root module which inform Angular about various files and codes.

environment - Environment Variables in Angular read this

app.module.ts:

Component
It is also a type of directive with template,styles and logic part which is most famous type of directive among all in Angular2. In this type of directive you can use other directives whether it is custom or builtin in the @Component annotation like following:

The Complete Guide to Angular Performance Tuning

https://christianlydemann.com/the-complete-guide-to-angular-performance-tuning/

Improving change detection
Change detection can be the most performance heavy in Angular apps and therefore it is necessary to have some awareness of how to render the templates most effectively, so you are only rerendering a component if it has new changes to show.

OnPush change detection
The default change detection behavior for components is to re-render every time an asynchronous event has happened in the app such as click, XMLHttpRequest, setTimout. This can become a problem because this will cause many unnecessary renderings of the templates, that may not have been changed

OnPush change detection fixes this by only re-rendering a template if either:

One of its input properties has gotten a new reference
An event from the component or one of its children eg. click on a button in the component
Explicit run of change detection
To apply this strategy you just need to set the change-detection strategy in the component‚Äôs decorator:

@Component({
  selector: 'app-todo-list',
  templateUrl: './todo-list.component.html',
  styleUrls: ['./todo-list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class TodoListComponent implements OnInit {


Design for immutability  (unchanging over time)

To leverage this method you need to make sure, that all state changes are happening immutably because we need a new reference provided to a component‚Äôs input to trigger change detection with onPush. If you are using Redux for state management, then you would naturally get a new instance every time the state changes, which will trigger change detection for onPush components when provided to a component‚Äôs inputs. With this approach you want to have container components, that is responsible for getting the data from the store and presentation component, which will only interact with other components using input and output.

presentation component <-> container component <-> redux store 

The easiest way to provide the store data to the template is using the async pipe. This will look like having the data outside of an observable and will make sure to clean up the stream when the component gets destroyed automatically.

<div class="todo-list-wrapper" *ngIf="(todoList$ | async) as todoList">

Make onPush the default change detection strategy
Using schematics you can make onPush the default changeDetection strategy when generating new components with Angular CLI. You simply add this to the schematics property in Angular.json:

 "changeDetection": "OnPush"
 
 Using pipes instead of methods in templates
Methods in a template will get triggered every time a component gets rerendered. Even with onPush change detection, that will mean that it gets triggered every time there is interaction with the component or any children of the component (click, type). If the methods are doing heavy computations, this will make the app slow as it scales as it keeps recomputing every time there is interaction with the component.

What you can do instead is using a pure pipe to make sure, that you are only recomputing when the input to the pipe changes. async pipe, as we looked at before, is an example of a pure pipe. 

A pure function
There‚Äôs so much information on the web about functional programming that probably every developer knows what a pure function is. For myself I define a pure function as a function that doesn‚Äôt have an internal state. It means that all operations it performs are not affected by that state and given the same input parameters and produces the same deterministic output.

const addPure = (v1, v2) => {
  return v1 + v2;
};

const addImpure = (() => {
  let state = 0;
  return (v) => {
    return state += v;
  }
})();

If I call both functions with the same input, say number 1, the first one will produce the same output 2 on every call:

addPure(1, 1);  // 2
addPure(1, 1);  // 2
addPure(1, 1);  // 2
while the second one produces different output:
addImpure(1);  // 1
addImpure(1);  // 2
addImpure(1);  // 3

So the key takeaway here is that even if the input doesn‚Äôt change the impure function can produce different output. It means that we cannot use the input value to determine if the output will change.

Pure:
input parameters value determine the output so if input parameters don‚Äôt change the output doesn‚Äôt change
can be shared across many usages without affecting the output result
Impure:
cannot use the input value to determine if the output will change
cannot be shared because the internal state can be affected from outside

This has the consequence of triggering the method every time a button is clicked inside of the component that is even using onPush change detection:

With pipe
We fix this by converting the method to a pipe, as a pipe as default is pure it will rerun the logic if the input changes (reference change).
Now, this pipe is only being triggered when the input (todolist) has changed.

Cache values from pure pipes and functions
Even when using pure pipes, we can optimize this further by remembering/caching previous values, so we don‚Äôt need to recompute if we already run the pipe with the same input in the past. Pure pipes don‚Äôt remember the previous values, but will just make sure that if the input hasn‚Äôt changed the reference, it will not recompute. To do the caching of previous value we need to combine it with something else.
An easy way to do this is to use Lodash memorize method. In this case, this is not very practical as the input is an array of objects. If the pipe was taking a simple data type, such as number as input, it could be beneficial to use this as a key to cache results and thus avoid recomputation.


Using trackBy in ngFor
When using ngFor and updating the list, Angular will by default remove the whole list from the DOM and create it again, because it has no way, by default, to know which item has been added or removed from the list. The trackBy function is solving this by allowing you to provide Angular with a function used for evaluating, which item has been updated or removed from the ngFor list, and then only rerender that.

 public trackByFn(index, item) {
    return item.id;
  }
  
  This will track changes in the list based on the id property of the items (todo items).

The trackBy function is used in the template like this:

<ul class="list-group mb-3">
    <app-todo-item-list-row *ngFor="let todo of todos; trackBy: trackByFn" [todoItem]="todo" (todoDelete)="deleteTodo($event)" (todoEdit)="editTodo($event)"></app-todo-item-list-row>
  </ul>
  
  Improving page load
The page load time is an important aspect of user experience today. Every millisecond a user is waiting, potentially means a loss in revenue, because of a higher bounce rate and worse user experience, so this is a place you should optimize. Page load time also has an impact on SEO, as faster websites are rewarded by search engines.

For improving page load we want to use caching using Angular PWA, lazy loading and bundling.

Cache static content using Angular PWA
Caching the static content will make your Angular app load faster as it will already be in the browser. This is easily done using Angular PWA which will use service workers to cache the static content, that is the js, css bundles, images and static served files, and present them without making a call to the server.

I have already created a guide to how to setup caching with Angular PWA you can read here.

Cache HTTP calls using Angular PWA
With Angular PWA you can easily set up caching rules for HTTP calls to give a faster user experience without cluttering your app with a lot of caching code. Either you can optimize for freshness or performance, that is, you can either choose to only read the cache if the HTTP call times out or first check the cache and then only call the API then the cache expires.

I have a guide with a video showing you how to do this here.


Lazy load routes
Lazy loading routes will make sure that a feature will be bundled in its own bundle and that this bundle can be loaded when it is needed.

To set up lazy loading we simply create a child route file like this in a feature:

Optimizing bundling and preloading
To optimize page load even further you can choose to preload the feature modules, so navigation is instant when you want to render a lazily loaded feature module.
This can be done by setting the: preloadingStrategy to PreloadModules as:

    RouterModule.forRoot(routes, {
      preloadingStrategy: PreloadAllModules
    })
	
	Server-side rendering with Angular Universal
For Angular apps that are containing indexed pages, it is recommended to server-side render the app. This will make sure the pages are being fully rendered by the server before shown to the browser which will give a faster page load. This will require that the app is not dependent on any native DOM elements, and you should instead inject 

Improving UX
Performance tuning is all about optimizations at the bottleneck, that is the part of the system that is affecting your user experience the most. Sometimes the solution could just be to handle actions more optimistically and thus less waiting for the user.

How should I prioritize performance tuning?
Start with low hanging fruits: onPush, Lazy loading and then PWA and then gain awareness of where your performance bottlenecks are in the system. Every improvement that is not at the bottleneck is an illusion as it will not improve the user experience with the app. Tuning methods like detaching the change detection should only be used if you have a specific problem with a component‚Äôs change detection impacting performance.

OnPush
Lazy loading modules
Improve page load with Angular PWA
trackBy for ngFor
Pure pipes instead of methods (including async)
Cache values from pipes and pure functions
Cache HTTP requests better
Detach/manual change detection
Angular Universal

Why is Angular Universal the last one? Because introducing server-side rendering can cause big changes to the development setup (need to maintain another server, cannot reference DOM and need to maintain a server and a client bundle) and should be used either for performance reasons that can not be fixed with the previous steps or SEO purposes.

https://github.com/lydemann/angular-performance-tuning-guide

angular trainer

github.com/lydemann

christianlydemann.com/
git

https://christianlydemann.com/angular-architect-course-video/


AOT Compilation
When running a production build, Angular using JIT (just in time) compilation, which essentially means, Angular compiles your views in the browser at runtime. This has two downsides. First, the compilation process must run before your application can be used, and this can increase the time it takes for your site to load. Secondly, we have to ship the Angular compiler with your application, and it is not a small module!

By taking advantage of AOT (ahead of time) compilation, we move this step to build time so we do it once when building our application, and only ship the compiled templates. We can now remove the Angular compiler from our bundle (reducing our bundle size by ~1mb) and allows us to skip the compilation step making our pages load much quicker!

Minification
Code minification is the process tools like UglifyJS perform to optimize the code we have written. It performs many optimizations, for example, removing whitespace, renaming properties, dead code elimination and much much more.

When developing having well named variables make development much easier, but when shipping our applications we don‚Äôt need these names to be so helpful, so while averageUserAge might be useful when developing this could be renamed to a1 reducing the amount of code needed to be shipped.


12. Unsubscribe
As previously mentioned, Angular uses observables quite a lot, and if you make any HTTP requests or are listening to router events, you will too.

Observables are great, but you need to ensure once you are finished with them that you unsubscribe, otherwise memory leaks can occur and this can cause performance issues.

Unsubscribing is easy, you store the subscription, and then use the ngOnDestroy lifecycle hook to unsubscribe, eg:

export class AppComponent implements OnDestroy {
    private _subscription: Subscription;

    constructor(router: Router) {
        this._subscription = router.events.subscribe(event => {
            // do stuff here

        });
    }

    ngOnDestroy(): void {
        this._subscription.unsubscribe();
    }
}


14. Profiling
There are many things that I can list to improve performance and even if your application followed everything listed here you may still have performance issues. That is simply because each application is different, it will use different third party libraries and be architected differently. And this is where profiling comes in!

The developer tools for all modern browser come equipped with performance profiling tools to help identify code that is running slowly, which is great to help figure out how you can improve it further.

There are a few other tools you can use to help improve performance, first the Webpack Bundle Analyzer. This tool allows you to visually explore your bundle. It can let you see what modules or libraries are the largest, but more importantly it can help identify items that should not have been included in the bundle. For example if you are using an older version of RxJS, accidentally importing directly from rxjs would have included the whole library in your bundle. Tools like this can help spot this kind of mistake and allow you to easily rectify it.


Lighthouse testing is another great way to see how you application performs on a range of devices. It is a tool now built in to the Chrome Dev Tools. It will profile many aspects of your application, such a load performance, accessibility, PWA support, SEO optimization and Best Practices. It can also give you a good indication about how well your site will perform in regards to Google rankings as many of these criteria it tests for will affect the site ranking.







